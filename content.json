{"meta":{"title":"徐乔伟","subtitle":"","description":"徐乔伟的个人博客","author":"徐乔伟","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-09-25T08:04:37.346Z","updated":"2022-09-25T08:04:37.346Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2022-09-25T08:17:53.053Z","updated":"2022-09-25T08:17:53.053Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-25T08:06:39.390Z","updated":"2022-09-25T08:06:39.390Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"layout: friends # 必须title: 我的朋友们 # 可选，这是友链页的标题 这里写友链上方的内容。","text":"layout: friends # 必须title: 我的朋友们 # 可选，这是友链页的标题 这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2022-09-25T08:07:13.457Z","updated":"2022-09-25T08:07:13.457Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"从零实现Golang的HTTP标准库-（3）","slug":"从零实现Golang的HTTP标准库-（3）","date":"2022-10-06T00:20:00.000Z","updated":"2022-10-05T16:41:35.579Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-（3）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%EF%BC%883%EF%BC%89.html","excerpt":"","text":"1.概述本文将正式开始HTTP协议的解析，主要完成Request结构体的属性组成，HTTP请求报文首部字段以及请求行的解析。 2.关于io包、ioutil包、bufio包的整理在上一篇中，我们对conn结构体进行了改进。 其中，提到了有关于标准库的bufio包的内容，包括bufio.Reader以及bufio.Writer等。 在上一篇中，对于这部分内容只是做了一个简单的介绍，在本篇中，我将单独对这部分内容进行一个梳理，并额外扩充了ioutil包以及io包等相关的内容。 这部分内容并不难，通常只是一些结构体和方法的梳理。但如果事先没能够很好理解结构体或方法的意义，往往会对理解后面的代码造成困难。 1.io包 IO 操作是我们在编程中不可避免会遇到的，例如读写文件，Go语言的 io 包中提供了相关的接口，定义了相应的规范，不同的数据类型可以根据规范去实现相应的方法，提供更加丰富的功能。 io.Reader io.Reader接口定义了 Read 方法，用于读取数据到字节数组中： 入参：字节数组 p，会将数据读入到 p 中 返回值：本次读取的字节数 n，以及遇到的错误 err 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 方法功能详解 方法读取数据写入到字节数组 p 中，由于 p 是有大小的，所以一次至多读取 len(p) 个字节 方法返回读取的数据字节数 n(0 &lt;&#x3D; n &lt;&#x3D; len(p))，以及读取过程中遇到的 error 即使一次调用读取到的数据小于 len(p)，也可能会占用整个字节数组 p 作为暂存空间 如果数据源的数据量小于 len(p) 个字节，方法只会读取当前可用数据，不会等待更多数据的到来 io.Writer io.Writer接口定义了 Write 方法，用于写数据到底层文件中 入参：字节数组 p，会将 p 中的数据写入到底层文件中 返回值：成功写入完成的字节数 n，以及遇到的错误 err 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 方法功能详解 该方法将 p 中的数据写到文件中 方法返回成功写入的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)），以及写入过程中遇到的错误 err 如果 n&lt;len(p)，方法必须返回 err!&#x3D;nil 方法一定不能修改字节数组 p，即使是临时修改也不被允许 总结 io.Reader : 读取底层文件中的数据到字节数组中io.Writer : 将字节数组的数据写入到底层文件中 可以看到 Reader 和 Writer 接口中定义的方法中，都有字节数组p，而底层要操作的文件在方法中却没有体现出来,我们只需要知道底层文件会通过p被read和write操作即可。 Read方法是将文件的数据读入字节数组p，Write 是将字节数组p的数据写入文件，这一点不要记混。","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"从零实现Golang的HTTP标准库-（2）","slug":"从零实现Golang的HTTP标准库-（2）","date":"2022-10-05T14:20:00.000Z","updated":"2022-10-05T14:59:53.557Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-（2）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%EF%BC%882%EF%BC%89.html","excerpt":"","text":"1.概述在上一篇中，我们介绍了如何启动一个Web服务， 在本篇中，我们主要构建框架的基本结构，即所需要的一些结构体。 我们暂时需要4个结构体： ① Server：代表WEB服务器，属性包含监听地址Addr以及Handler，负责服务器的启动逻辑。 ② conn：代表HTTP连接，net.Conn表达能力过弱，故将其封装成conn。仅服务于框架内部，不应由用户使用，包内不可导出。 ③ Request：代表客户端的HTTP请求，由框架从字节流中解析http报文从而生成的结构。 ④ response：代表响应，实现了ResponseWriter接口。包内不可导出。 2.结构体构建本节只为搭建框架的骨干，因此部分结构体内部暂时为空，部分函数也空实现，在随后的章节中我们一步步进行填充。 1.requset.go 123type Request struct&#123;&#125;func readRequest(c *conn)(*Request,error)&#123;return nil,nil&#125; //暂时空实现 Request结构体就代表了客户端提交的http请求，我们使用readRequest函数从http连接上解析出这个对象。 它是http.Handler的ServeHTTP方法的第二个参数。 2.response.go 123type response struct&#123;&#125;type ResponseWriter interface&#123;&#125; response结构体就代表服务端的响应对象，我们后期会给其绑定些与客户端交互的方法，供用户使用。这里暂时让response和ResponseWriter都空实现。 它是http.Handler的ServeHTTP方法的第一个参数。 3.server.go 1234567891011121314151617181920212223type Handler interface &#123; ServeHTTP(w ResponseWriter,r *Request)&#125;type Server struct&#123; Addr string //监听地址 Handler Handler //处理http请求的回调函数&#125;func (s *Server) ListenAndServe()error&#123; l,err:=net.Listen(&quot;tcp&quot;,s.Addr) if err!=nil&#123; return err &#125; for&#123; rwc,err:=l.Accept() if err!=nil&#123; continue &#125; conn:=newConn(rwc,s) go conn.serve() // 为每一个连接开启一个go程 &#125;&#125; rwc是net包里的那个连接，此时还没有封装成代表http的连接。conn是封装好的连接对象。通过newConn（rwc）初始化出来。 conn是封装好的连接对象，它隶属于一个conn结构体。这个conn结构体里面提供了一个serve方法。这个serve方法就是用来处理连接的。Serve方法主要干三件事：一个是从连接中解析出客户端的请求request，另一个是设置response。这是serverHTTP方法的两个参数。最后一个是调用serverHTTP方法。注意：这个serverHTTP方法是和具体的tcp连接绑在一起的，而不是和封装好的那个连接绑在一起的。 上一节提到启动一个服务器其必须项只有Addr以及Handler，他们分别告诉了框架监听地址以及如何处理客户端的请求。事实上，Server结构体中还可以加入很多字段如读取或写入超时时间、能接受的最大报文大小等控制信息，但为了专注于一个框架最核心的实现，我们忽略这些细节内容。 ListenAndServe方法中展现的是go语言socket编程的写法，其大致意思是在Addr上监听TCP连接，将得到的TCP连接rwc(ReadWriteCloser)以及s进行封装得到conn结构体。接着调用conn.serve()方法，开启goroutine处理请求。 项目的开发尽量遵循模块分工原则，server.go只负责WEB服务器的启动逻辑，接下来的http协议的解析交给另一个模块conn.go进行。 4.conn.go 1234567891011121314151617181920212223242526272829303132333435type conn struct&#123; svr *Server // 引用服务器对象 rwc net.Conn // 底层tcp连接&#125;func newConn(rwc net.Conn,svr *Server)*conn&#123; return &amp;conn&#123;svr: svr, rwc: rwc&#125;&#125;func (c *conn) serve()&#123; defer func() &#123; if err:=recover();err!=nil&#123; log.Printf(&quot;panic recoverred,err:%v\\n&quot;,err) &#125; c.close() &#125;() //http1.1支持keep-alive长连接，所以一个连接中可能读出个请求，因此实用for循环读取 for&#123; req,err:=c.readRequest() //解析出Request if err!=nil&#123; handleErr(err,c) //将错误单独交给handleErr处理 return &#125; res:=c.setupResponse() //设置response // 有了用户关心的Request和response之后，传入用户提供的回调函数即可 c.svr.Handler.ServeHTTP(res,req) &#125;&#125;//暂时为空实现，后续小节再填充func (c *conn) readRequest()(*Request,error)&#123;return readRequest(c)&#125;func (c *conn) setupResponse()*response&#123;return nil&#125;func (c *conn) close()&#123;c.rwc.Close()&#125;func handleErr(err error,c *conn)&#123;fmt.Println(err)&#125; 对conn结构体作了扩充：拥有服务器属性、tcp连接属性。 在serve方法中，会分别调用readRequest以及setupResponse方法，从而得到Request以及response，随后将它们传入用户指定的Handler中，开启实际的请求处理过程。defer中使用recover，防止用户指定的Handler中存在逻辑错误导致发生panic。 利用for循环读取的原因： 对于HTTP 1.0来说，客户端为了获取服务端的每一个资源，都需要为每一个请求进行TCP连接的建立，因此每一个请求都需要等待2个RTT(三次握手+服务端的返回)的延时。而往往一个html网页中往往引用了多个css或者js文件，每一个请求都要经历TCP的三次握手，其带来的代价无疑是昂贵的。 因此在HTTP 1.1中进行了巨大的改进，即如果将要请求的资源在同一台服务器上，则我只需要建立一个TCP连接，所有的HTTP请求都通过这个连接传输，平均下来可以减少一半的传播时延。 如果客户端的请求头中包含connection: keep-alive字段，则我们的服务器应该有义务保证长连接的维持，并持续从中读取HTTP请求，因此这里我们使用for循环。 将err交给handleErr函数处理的原因： eadRequest可能会出现各种错误，如用户连接的断开、请求报文格式错误、服务器系统故障、使用了不支持的http版本、使用了不支持的协议等等错误。 对于有些错误如客户端连接断开或者使用了不支持的协议，我们服务端不应该进行回复。但对于一些错误如使用了不支持的http版本，我们应该返回505状态码；对于请求报文过大的错误，我们应该返回413状态码。因此在handleErr中，我们应该对err进行分类处理。 3.对conn结构体的改进目前conn结构体很简单，我们在读写两个方面进行分别改进，抽象出两个结构成员，一个负责对tcp连接读的逻辑，一个负责写的逻辑。两个改进如下： 1.写的改进 写的改进比较简单，主要是从性能优化角度出发。以下面代码为例： 12345http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; for i:=0;i&lt;100;i++&#123; io.WriteString(w,strconv.Itoa(i)) &#125; &#125;) 100次循环每次写入1~2B的小片段，每一次写入都会进行一次系统调用、一次IO操作，这势必会极大降低应用程序的性能。很显然，可以对用户写入数据进行缓存，缓存不下时再发送就能较少IO次数，从而提升效率。 go标准库提供了现有的工具，不需要重复造轮子。bufio.Writer可以解决我们的问题，它的底层会分配一个缓存切片，我们对这bufio.Writer写入时会优先往这个切片中写入，如果缓存满了，则将切片中缓存的数据发送到最底层的writer中，因此可以保证每次写入的大小都是大于或等于缓存切片的大小。在conn结构中引入bufw成员： 12345678910111213141516171819202122232425262728293031323334353637type conn struct&#123; svr *Server rwc net.Conn bufw *bufio.Writer //带缓存的writer&#125;func newConn(rwc net.Conn,svr *Server)*conn&#123; return &amp;conn&#123; svr: svr, rwc: rwc, bufw: bufio.NewWriterSize(rwc,4&lt;&lt;10), //缓存大小4kB &#125;&#125;func (c *conn) serve()&#123; defer func() &#123; if err:=recover();err!=nil&#123; log.Printf(&quot;panic recoverred,err:%v\\n&quot;,err) &#125; c.close() &#125;() //http1.1支持keep-alive长连接，所以一个连接中可能读出 //多个请求，因此实用for循环读取 for&#123; req,err:=c.readRequest() if err!=nil&#123; handleErr(err,c) return &#125; resp:=c.setupResponse() c.svr.Handler.ServeHTTP(resp,req) //将缓存中的剩余的数据发送到rwc中 if err=c.bufw.Flush();err!=nil&#123; return &#125; &#125;&#125; 我们给conn加入了bufw属性，以后的写入操作都将直接操纵bufw，其缓存的默认大小为4KB。同时在serve方法中，在一个请求处理结束后，bufw的缓存切片中还缓存有部分数据，我们需要调用Flush保证数据全部发送。 2.读的改进 对于HTTP协议来说，一个请求报文分为三部分：请求行、首部字段以及报文主体，一个post请求的报文如下： 123456789POST / HTTP/1.1\\r\\n #请求行Content-Type: text/plain\\r\\n #2~7行首部字段，首部字段为k-v对User-Agent: PostmanRuntime/7.28.0\\r\\nHost: 127.0.0.1:8080\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nConnection: keep-alive\\r\\nContent-Length: 18\\r\\n\\r\\nhello,I am client! #报文主体 其中首部字段部分是由一个个key-value对组成，每一对之间通过\\r\\n分割，首部字段与报文主体之间则是利用两个连续的CRLF即\\r\\n\\r\\n作为分界。首部字段到底有多少个key-value对于服务端程序来说是无法预知的，因此我们想正确解析出所有的首部字段，我们必须一直解析到出现两个连续的\\r\\n为止。 对于一个正常的http请求报文，其首部字段总长度不会超过1MB，所以直接不加限制的读到空行完全可行，但问题是无法保证所有的客户端都没有恶意。 他可能在阅读框架源码后发现对首部字段的读取未采取任何限制措施，于是发送了一个首部字段无限长的http请求，导致服务器无限解析最终用掉了所有内存直至程序崩溃。因此我们应该为我们的reader限制最大读取量，这是第一个改进，改进用到了标准库的io.LimitedReader。 除此之外，首部字段的每个key-value都占用一行(\\r\\n是换行符)，为了方便解析，我们的reader应该有ReadLine方法。这是第二个改进，改进用到了标准库的bufio.Reader。 代码变动如下： 123456789101112131415161718type conn struct&#123; svr *Server rwc net.Conn lr *io.LimitedReader bufr *bufio.Reader //bufr是对lr的封装 bufw *bufio.Writer&#125;func newConn(rwc net.Conn,svr *Server)*conn&#123; lr:=&amp;io.LimitedReader&#123;R: rwc, N: 1&lt;&lt;20&#125; return &amp;conn&#123; svr: svr, rwc: rwc, bufw: bufio.NewWriterSize(rwc,4&lt;&lt;10), lr:lr, bufr: bufio.NewReaderSize(lr,4&lt;&lt;10), &#125;&#125; 第一处改进：为conn增加了lr字段，它是一个io.LimitedReader，它包含一个属性N代表能够在这个reader上读取的最多字节数，如果在此reader上读取的总字节数超过了上限，则接下来对这个reader的读取都会返回io.EOF，从而有效终止读取过程，避免首部字段的无限读。 第二处改进：为conn增加bufr字段，它是一个bufio.Reader，其底层的reader为上述的LimitedReader。对于一个io.Reader接口而言，它是无法提供ReadLine方法的，而将其封装程bufio.Reader后，就可以使用这个方法。 bufio.Reader相较io.Reader来说多出了ReadLine方法的原因： io.Reader提供的Read方法需要传入一个切片，如果传入的切片太小了，可能导致一行未读完；如果传入的切片太大了，则可能导致读取超过了一行。首部字段中的任何一行其长度是不可预知的，所以单纯利用io.Reader的Read方法很难达成目的。当然你可以传入一个字节大小的切片，每次读取1B然后通过不断append的方式，但这样会带来多次的IO开销。 bufio.Reader相较于io.Reader的改进就是，它会存在一个缓存切片，如果缓存切片中存在数据，我们对bufio.Reader进行Read优先会从这个缓存中取。我们平时会遇到一个使用场景就是，我们希望查看一下某个reader中的前多少B的数据，但又不希望我们这次查看之后后续的Read方法再也读不到这些数据，这时我们会将其转为一个bufio.Reader，通过其Peek方法就可以实现上述的要求。其原理就是Peek方法会将你peek出的数据暂存入切片缓存，尽管底层的reader流中不存在了这些数据，但对bufio.Reader进行Read会优先从缓存取，依旧可以将以前消费的数据读取出来。 ReadLine方法就是借助了这个缓存，它会不断地读取数据，如果读取的数据不够一行，则会将这些数据暂存；如果读取的数据够了一行，则将这一行返回，并将剩余未够一行的数据继续缓存。这样不论是一次读多读少，都不会影响Read方法的调用，同时也能减少IO次数提升性能。具体实现可以查看标准库bufio.go源码。 那么以后，我们直接操作的IO对象就是bufr和bufw： 读数据时直接操作bufr，bufr进而读取io.LimitedReader，进而读取tcp连接。 写数据时直接操作bufw，bufw进而写入到tcp连接。 4.测试编写main.go： 1234567891011121314151617181920package mainimport ( &quot;example/httpd&quot; &quot;fmt&quot;)type myHandler struct &#123;&#125;func (*myHandler) ServeHTTP(w httpd.ResponseWriter,r *httpd.Request)&#123; fmt.Println(&quot;hello world&quot;)&#125;func main()&#123; svr:=httpd.Server&#123; Addr: &quot;127.0.0.1:8080&quot;, Handler:new(myHandler), &#125; panic(svr.ListenAndServe())&#125; 由于目前未解析request以及response，所以无法去真正写我们的业务代码，但可以测试我们的Handler是否能被正常触发。执行curl命令： 1curl 127.0.0.1:8080 测试的执行流程为：框架使用者先指定一个myhandler结构体，给结构体绑定一个serverhttp方法，自己自定义实现serverhttp（其实是继承handler并重写）。 然后在main函数里面初始化一个server服务器对象svr，然后调用服务器对象的listenandserve方法，然后转进入到conn的serve方法，serve方法最后调用服务器对象的handler属性，handler是一个接口，里面有serverhttp方法但没有去实现，故handler可以调用serverhttp方法。 5.总结这一章我们完成了httpd框架骨干的搭建，以及完成对conn的封装。下一章则正式开始HTTP协议的解析工作，我们将封装Request、完成请求行以及请求首部字段的解析。 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"从零实现Golang的HTTP标准库-（1）","slug":"从零实现Golang的HTTP标准库-（1）","date":"2022-10-05T02:21:31.000Z","updated":"2022-10-05T14:18:52.922Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-（1）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%EF%BC%881%EF%BC%89.html","excerpt":"","text":"1.前言在正式开始我们对Golang的HTTP标准库的实现之前，我还是想先推荐几个学习资源！ 这几个学习资源不是我们实现HTTP标准库所需的必备知识，所以我没有将他们放在前文的预备知识篇中，但是这几个资料的实现过程都和HTTP标准库有着一定相同的地方。 但如果你能够提前对以下推荐的几个学习资源事先做了阅读与研究，那么在实现Golang的HTTP标准库的过程中一定会如鱼得水，得心应手。 B站韩顺平的网络编程部分p294-p343 这一部分韩老师讲解了一个案例，其中的服务端部分思路值得借鉴。 B站刘丹冰的Zinx轻量级TCP服务框架 这个课程的质量非常高，up主刘丹冰老师的讲课风格十分干练，直击重点。在这门课中，老师实现了一个TCP服务框架，其实非常类似于我们将要实现的HTTP标准库，有很多思路都是共通的。我强烈建议大家有空的时候先完成对这门课程的学习，一定能够在这门课程中提前学到HTTP标准库的一些难点。 一位华科同学的博客 这个博客的博主是华中科技大学的一名计算机专业研究生，他在博客中记录了自己实现HTTP标准库的过程，其质量之高，让我收获良多。但由于博主计算机基础非常扎实，其语言风格比较干练，默认读者具有了一定的网络编程水平，故我在阅读的过程中对于一些细节之处难以理解，遇到了不少的阻碍。经过反复阅读与研究，我在阅读过程中做了不少的笔记，都是基于原博客写出来的，可以说，正是看了原博主的关于从零实现HTTP标准库的内容，让我萌发了对HTTP标准库研究的兴趣。所以，无论你之前是否有过网络编程基础，只要你想尝试研究实现HTTP标准库，你都应该或者说必须去看看这个博客。对于基础好的同学，我相信原博客内容已经能够满足你的需要；对于一些和我一样事先不太了解网络底层编程的同学，我觉得你仍需先看看原文的博客，当看到某处难以理解时，可以参考参考我博客中对应的地方，也许这处也是我当时疑惑的点。因此强烈建议各位去看看这个博客，我在此也对博主辜飞俊同学表示感谢！ 极客时间web框架教程 这是一门手把手教你写一个web框架的课程，总体来说应该具有一定的难度。我目前也没有学习完这门课程，但我认为其质量也是非常好的，可以作为我们实现完HTTP框架后的一个进阶与补充。其中，文章开头就以Golang的net&#x2F;HTTP标准库为例，引领读者一步步实现web框架。 以上四个内容都是我在学习过程中发现的优质资源，都对我有着比较大的帮助，所以也分享出来给大家学习。 2.概述Go语言的官方net&#x2F;HTTP标准库，搭建一个webServer非常容易。因为这个搭建过程中所使用到的函数、方法、接口往往是标准库帮我们封装好了的，我们只需要根据现成的已有的工具即可完成搭建。而我们今天将要实现的自然并不是使用现成的工具，而是要钻进HTTP标准库源码中，看看这些工具是怎么设计、怎么封装的。 3.webServerwebServer在维基百科上的解释为：Web Server 是一个通过 HTTP 协议处理 Web 请求的计算机系统。 HTTP 协议，在 OSI 网络体系结构中，是基于 TCP&#x2F;IP 之上第七层应用层的协议，全称叫做超文本传输协议。啥意思？就是说 HTTP 协议传输的都是文本字符，只是这些字符是有规则排列的。这些字符的排列规则，就是一种约定，也就是协议。这个协议还有一个专门的描述文档，就是RFC 2616。 对于 HTTP 协议，无论是请求还是响应，传输的消息体都可以分为两个部分：HTTP 头部和 HTTP Body 体。头部描述的一般是和业务无关但与传输相关的信息，比如请求地址、编码格式、缓存时长等；Body 里面主要描述的是与业务相关的信息。 Web Server 的本质，实际上就是接收、解析 HTTP 请求传输的文本字符，理解这些文本字符的指令，然后进行计算，再将返回值组织成 HTTP 响应的文本字符，通过 TCP 网络传输回去。 4.标准库启动Web服务的示例用 net&#x2F;http 来创建一个 HTTP 服务，其实很简单，下面是官方文档里的例子。我做了些注释，帮你理解。 1234567891011// 创建一个Foo路由和处理函数http.Handle(&quot;/foo&quot;, fooHandler)// 创建一个bar路由和处理函数http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))&#125;)// 监听8080端口log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil)) 有基础的同学是可以看得懂上述代码的，无非是注册了两个路由，然后让服务器监听在8080端口上并运行。 但是零基础的同学看着上述代码，那可就疑问多多了，Handle是啥？HandleFunc是啥？ListenAndServe又是啥？有什么作用呢？不要担心，我最开始也是这样。 不要在意上面的代码细节，暂时有个印象，先继续往下看吧！ 5.自编代码启动Web服务第4节中的代码是官方的写法，他其实已经是经过了一些封装和简化的，那我们现在就自己动手写一个启动Web服务的代码，没有封装、没有简化，从这个自编代码入手开始学习！ 注意：官方代码中前两个方法是注册路由，关于这一块我们目前无需涉及，所以我先将路由这部分省略！ 1234567891011121314151617package mainimport &quot;net/http&quot;type myHandler struct&#123;&#125;func (*myHandler) ServeHTTP(w http.ResponseWriter,r *http.Request)&#123; w.Write([]byte(&quot;hello world!&quot;))&#125;func main()&#123; svr:=&amp;http.Server&#123; Addr: &quot;127.0.0.1:8080&quot;, Handler: new(myHandler), &#125; panic(svr.ListenAndServe())&#125; 我们来解析一下上述代码！解析过程并没有按照代码顺序，因为代码间存在先后因果的逻辑关系，需要仔细梳理！ 第1-3行为在main包下，引入“net&#x2F;http”库。 在main函数中，第12行我们初始化了一个http.server的对象并对其进行属性进行赋值，起名叫svr。 那么这个http.server是什么呢？它其实是一个结构体，代表了一个我们将要启动的服务器。 123456789type Server struct &#123; // 请求监听地址 Addr string // 请求核心处理函数 Handler Handler // 为了理解方便，其余非核心属性省略 ...&#125; 你可以看到这个server服务器结构体中有两个核心属性： 一个是String类型的Addr，初始化server时给Addr赋值表示希望服务器监听哪个地址端口； 一个是Handler类型的Handler，Handler是一个有ServeHTTP方法的接口，就好比一个拦截所有http请求的拦截器，告诉框架如何处理来自客户端的所有http请求。 我们来重点解析一下这个Handler接口。它代表了一个抽象的业务处理逻辑。 在自编代码中，我们在初始化服务器对象时，除了给Addr赋值，我们也给Handler属性进行了赋值，其值为myHandler。 显而易见，这个myHandler是我们自己定义的一个结构体，它会去实现Handler接口，因而myHandler可以赋值给Handler。前面说了这个Handler代表了一个抽象的业务处理逻辑，我们自己写这个myHandler并赋值给Handler，目的就是我们想要自己定义这个处理逻辑。 注意： 不论是Handler还是myHandler，他们都是代表抽象的笼统的，请不要将myHandler理解为具体的业务处理方法。具体的处理方法是另一个东西叫serverHTTP方法，这个serverHTTP方法是Handler接口里的一个成员方法，而myHandler结构体实现了Handler里的这个成员方法，也即实现了Handler接口。 在初始化server时，也可以不给Handler进行赋值，也即我们不想要自定义处理方法，那么这时候标准库会启动自己的默认处理方式。 在serverHTTP方法中我们才真正的去定义具体的业务请求处理方法。 比如在自编代码中，我们对业务请求的处理非常简单：直接输出“hello world!” 关于这个serverHTTP方法的参数： w http.ResponseWriter ：从名字你可以将它理解为“响应构造器”。当我们收到一个HTTP请求后，我们的框架会对这个请求进行处理。请求处理完毕后，肯定要往回发送一个响应。我们直接调用这个响应构造器w的write方法，即可完成响应的发送。 r *http.Request ：这个很简单，就是我们服务器或者框架从客户端收到的请求。这个请求的类型为Request，很显然，这个类型到时候是需要我们后面自己构建的。 其实，当客户端发来一个请求时，它的请求形式是一个HTTP请求报文的形式。而我们服务器对客户端的响应也是一个HTTP响应报文的形式。我们框架要做的就是当接收到HTTP报文后，我们对HTTP报文进行解析，获取关键信息并将其封装成一个Request结构体形式，代表一个请求。有了这个请求后，进行处理请求，通过响应构造器的write方法构建一个HTTP响应报文，再将其发送回去。 最后，关于ListenAndServe()函数，可以参照一下下面这幅图。 这部分其实就和go的socket编程相关。 如果你觉得层次比较多，对照着思维导图多看几遍就顺畅了。这里我也给你整理了一下逻辑线各层的关键结论： 第一层，标准库创建 HTTP 服务是通过创建一个 Server 数据结构完成的； 第二层，Server 数据结构在 for 循环中不断监听每一个连接； 第三层，每个连接默认开启一个 Goroutine 为其服务； 第四、五层，serverHandler 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理； 第六层，Server 数据结构如果没有设置处理函数 Handler，默认使用 DefaultServerMux 处理请求； 第七层，DefaultServerMux 是使用 map 结构来存储和查找路由规则。 最后，再多说一句，这个Handler接口除了有自定义处理逻辑的功能外，还有着路由的功能。 Handler的存在给框架的拓展带来了极大的灵活性，有了Handler，我们可以让任何一个HTTP请求以自己的规则映射到自己的路由。比如http标准库用ServeMux类型实现了Handler接口，从而实现了静态路由(将在本系列的末尾讨论)；gin的gin.Engine也是实现了自己的Handler，有了动态路由功能。 路由部分我们最后再说。 6.自定义框架的需求分析从需求分析的角度出发，看看我们要实现的web框架大体上需要哪些功能： http协议的解析不应该由开发者完成，我们需要从tcp字节流中解析出http的报文。 框架需要设置Request并为Request绑定易用API。 框架需要设置Response并为Response绑定易用API。 乍一看，我们需要给框架完成的功能甚少，但每一步都会有很多情况需要处理： 比如对于http 1.1协议来说，因为支持长连接，一个tcp连接能发送多个http请求，如果框架未正确完成上一个请求的解析(如未将当前报文主体全部读完)，那么随之到来的下一个请求就无法正确解析。 客户端有时会以chunk方式传输报文主体，我们应该保证用户read到的只有有效载荷(playload)，而没有chunk协议里的控制信息。 前端提交上来的form表单有多种类型，最常见的如application&#x2F;x-www-form-urlencoded以及multipart&#x2F;form-data，我们框架应该予以区分并分别提供解析方法。 服务端发送的数据是放在http响应报文的响应体中，客户端怎么知道我们发送了多少数据呢？一般来说可以查看响应头中的Content-Length字段，从而知道响应体的长度。观察上述的代码的ServeHTTP方法，我们并没有显式为头部指定Content-Length，但客户端依旧可以完整的读取出数据，这就说明标准库帮助我们完成了相关的设置工作。 从可行性角度来说，框架为我们的每一次响应都自动正确设置Content-Length(以下简称CT)是不现实的，发送CT所在的响应头必须是先于发送响应报文主体的，如果框架要自动设置CT，也就意味着我们必须为用户Write的所有数据进行缓存，这对一定长度内的发送量还实用，但对于大响应主体来说绝对是不可行。所以我们的框架还需要在必要时刻转化为利用chunk方式传输数据，这一部分对用户来说必须是无感知的。 7.总结本篇是从零实现Golang的HTTP标准库服务端部分的第一篇，开头给大家推荐了几个优秀的学习资源，然后介绍了webServer，标准库启动webServer的方法以及我们自定义启动webServer的方法并进行了详细的分析，最后给出了我们框架的需求以及难点。 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"从零实现Golang的HTTP标准库-预备知识（2）","slug":"从零实现Golang的HTTP标准库-预备知识（2）","date":"2022-10-04T14:17:12.000Z","updated":"2022-10-04T10:30:26.038Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-预备知识（2）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89.html","excerpt":"","text":"1.概述在预备知识（1）中，我们介绍了三个学习内容，其中前两个学习内容：go语言的基础语法以及计算机网络的概念了解，我们不再详细介绍与梳理，请读者自行完成这两个部分的学习。 在本篇中，我将对socket编程流程做一个简单的介绍，同时梳理一下go语言的socket编程。 本篇默认你已经对socket有所了解，故基本的概念性问题将不再被提及。如果你在阅读以下内容的过程中，有任何不明白的地方，去看上一篇文章中推荐的学习资源，里面应该都会有答案，或者直接网上搜索疑问。 2.传统TCP套接字编程流程注意：以下内容是我学习《计算机网络自顶向下》中相关部分自己总结而来，可能存在说辞严谨性问题，目的只是为了提供给大家一个借鉴和参考。具体也可以听一听中科大郑老师的课上的讲解！ TCP套接字编程流程：1 服务器首先运行，等待连接建立。 1.1 服务器创建一个欢迎socket，即可以返回一个整数。 此时这个整数无任何意义。创建socket可以调用socket API的创建函数。 1.2 将这个整数和服务器本地的IP和服务器本地端口相捆绑，捆绑可以调用socket API的捆绑函数。 1.3 在服务器的欢迎scoket上阻塞式的等待接收用户的连接。即调用socket API的accept函数，接收来自远端的用户和服务器的欢迎scoket进行TCP连接。如果此时没有连接，则函数停在当前不往下走，即阻塞式等待连接。 2 客户端主动与服务器建立连接 2.1 客户端创建本地socket，不需要捆绑，是隐式自动捆绑。 2.2 指定服务器进程的IP地址和端口号，与服务器进程连接。 3 服务器收到来自客户端的连接请求3.1 服务器接收来自用户端的连接请求，解除阻塞式等待。 此时服务器会返回一个新的socket整数 新的socket叫connection socket，这个connection socket仍然和服务器的IP、端口捆绑但同时connection socket又和客户端的IP和端口相捆绑。此时连接建立完成。 这个新的connection socket就是通道，在这个通道上就可以收和发。 3.传统TCP套接字编程伪代码1.welcomeSocket&#x3D;Socket（）;&#x2F;&#x2F;创建一个欢迎socket 2.bind（welcomeSocket&amp;sad）&#x2F;&#x2F;将欢迎socket和服务器本地IP、端口相捆绑 3.connectionSocket&#x3D;accept（welcomeSocket）&#x2F;&#x2F;在welcomeSocket所在的的端口上阻塞式等待来自客户端用户的连接请求 4.clientSocket&#x3D;socket（）；&#x2F;&#x2F;创建一个客户端本地的clientSocket 5.connect（clientSocket，sad）&#x2F;&#x2F;将客户端的socket和服务器的ip、端口捆绑此时客户端的TCP实体向服务端发出一个连接建立请求，服务端收到请求后解除阻塞，accept会返回一个新的值connectionSocket，且服务端TCP实体给出连接建立响应，客户端处connect返回一个有效值clientSocket，此时连接建立。 6.客户端用clientSocket发送信息，用到send函数。 7.服务器端用connectionSocket接收信息，用到read函数。 8.服务器端用connectionSocket处理信息，用到write函数。 9.客户端用clientSocket接收信息，用到read函数。 10.关闭掉本次connectionSocket，等待用户下一次连接建立请求。关闭掉本次clientSocket。 用到close函数 以上为传统编码形式的TCP Socket编程。 (1) 建立Socket：使用socket()函数。 (2) 绑定Socket：使用bind()函数。 (3) 监听：使用listen()函数。或者连接：使用connect()函数。 (4) 接受连接：使用accept()函数。 (5) 接收：使用receive()函数。或者发送：使用send()函数。 4.go的socket编程以下内容是我学习B站韩顺平老师go语言基础课中网络编程部分的笔记，具体代码可以去视频中参考。 Golang TCP Socket编程： 1.分为服务器端和客户端，客户端可以有多个。 2.服务器端在8888端口监听，等待客户端的连接。 3.客户端向服务器端IP地址的端口8888建立连接，这个连接的双向箭头是Conn类型的，先记住。 4.服务器端有一个主线程P，当某一个客户端与服务器端建立连接后，这个主线程会开辟一个单独的协程goroutine来处理这个客户端的请求。 5.若有多个客户端，则可以开辟多个协程来处理。 5.go语言net包中的主要函数介绍本部分主要介绍net包中一些以后会用到的函数方法，详细内容参考以下链接。 https://studygolang.com/pkgdoc 12package netimport &quot;net&quot; net包提供了可移植的网络I&#x2F;O接口，包括TCP&#x2F;IP、UDP、域名解析和Unix域socket。 虽然本包提供了对网络原语的访问，大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。 1.Listen函数 func Listen(net, laddr string) (Listener, error)，用Listener类型和error类型接收。 解析：Listen函数是net包直接调用的函数，写作net.Listen（）。它里面含有两个参数，其中net是指网络协议的类型：TCP,UDP等，laddr是一个网络地址，由IP：端口号组成。Listen函数的作用是返回在一个本地网络地址laddr上监听的Listener。 net.Listen（x1，x2）就代表让服务器守候在x2端口上等候客户端的连接请求，并且连接必须是x1协议类型的。 2.Listener接口 12345678type Listener interface &#123; // Addr返回该接口的网络终端地址 Addr() Addr // Accept等待并返回下一个连接到该接口的连接 Accept() (c Conn, err error) // Close关闭该接口，并使任何阻塞的Accept操作都会不再阻塞并返回错误。 Close() error &#125; 如上所示，Listenr是一个监听接口类型，它是Listen函数的返回值类型。 比如说listenr是Listen函数的返回值，listener是Listener接口类型的“对象”。由最初的TCP套接字编程流程可知，accept函数是阻塞式的等待客户端和服务器进行连接，若连接上了，返回一个connection socket。 若没有连接上，则继续等待。在这里我们就可以用listenr对象调用Accept方法来实现。即listener.Accept（），因为accept是接口里的方法，所以可以直接调用。又因为需要阻塞式等待，所以该语句应该写在一个无限循环中。listener代表一个监听接口对象。关闭listener代表不监听了。 Accept() (c Conn, err error)再来细看Accept方法，返回值是Conn类型和error类型。 2.Conn接口 1234567891011121314type Conn interface &#123; // Read从连接中读取数据 Read(b []byte) (n int, err error) // Write从连接中写入数据 Write(b []byte) (n int, err error) // Close方法关闭该连接 // 并会导致任何阻塞中的Read或Write方法不再阻塞并返回错误 Close() error // 返回本地网络地址 LocalAddr() Addr // 返回远端网络地址 RemoteAddr() Addr&#125; Conn是Accept函数的返回值类型。 Conn接口代表网络连接。多个线程可能会同时调用同一个Conn的方法。 Conn也是一个接口类型。 这个Conn类型代表了一个客户端与服务器端的连接，也即前面图中提到的双向箭头，就是Conn接口类型的。 假如设Conn接口的对象是conn，那么这个conn就是传统编码中服务器端返回的那个connection socket。我们可以对这个conn进行读数据操作和写数据操作。 6.总结以上内容是我当时在学习这些知识时自己做的一些笔记，仅供大家参考！ 当你差不多掌握了上述预备知识以后，下面我们将真正步入Golang的HTTP标准库的实现中去！ 对于上述内容，你可以在实践的过程中慢慢体会！ 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"从零实现Golang的HTTP标准库-预备知识（1）","slug":"从零实现Golang的HTTP标准库-预备知识（1）","date":"2022-09-25T14:09:40.000Z","updated":"2022-10-04T10:32:00.663Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-预备知识（1）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89.html","excerpt":"","text":"1.概述在我们从零实现Golang的HTTP标准库之前，我们首先需要学习一些预备知识，学习了这些预备知识作为基础以后，我们才能更好的理解Golang的HTTTP标准库的代码，也有利于我们后面自己动手实现它。 在预备知识中，我不会过多介绍关于Golang的HTTP标准库有关的内容，这一部分的介绍等我们学习完预备知识以后，会更新在后续的真正实现HTTP标准库的文章中。 2.所需要的预备知识以及学习资源推荐 Golang的基本语法 B站韩顺平的go语言基础课 《go语言编程基础》 国内七牛云团队编写的书，国人编写，通俗易懂 《go语言程序设计》 Go语言圣经，经典书籍但翻译略显晦涩 因为我们是要实现Golang的HTTP标准库，所以首先我们需要了解Golang这门语言的基础语法。 当然，我们不需要对Go语言有特别深入的了解，只需要掌握一些基础的部分，如：变量的定义、结构体的创建、给结构体绑定函数、接口的定义、接口的实现、for循环的写法、结构体对象的初始化等等，以上这些经常出现在标准库代码中。 至于Go语言的一些深入特性，如闭包、管道、Groutine协程等的底层原理，在本系列中无需知晓，只需知道其作用即可。 计算机网络 B站中科大计算机网络教程 《计算机网络自顶向下》 经典书籍，你只需学习书中的应用层和传输层即可，在传输层的结尾你会了解到传统socket的编程方式。 这门课是计算机科学与技术专业或软件工程专业学生的必修专业课，要想知道什么是HTTP，自然离不开计算机网络的学习。 你需要学习有关于传输层的知识，包括TCP等，以及什么是socket。力求对于计算机网络课程有一个大体的概念了解。 go语言的socket编程 B站韩顺平的go语言基础课网络编程部分 在计算机网络课程中，你会了解到什么是socket，以及传统的socket编程方式流程步骤。 但是在go语言中，有着自己的一套socket编程方法，但是大体的思路原理却是一致的，所以你仍需先学习计算机网络，了解传统的socket编程，在此基础上，学习go语言的socket编程将会事半功倍。 注意：我们需要学习的是有关于TCP的socket编程。 3.总结关于上述的三个知识点或者说三部分学习内容，难度不大，不需要花费你太多的精力。 但是却是我们实现Golang的HTTP标准库的基础，所以需要认真学习对待。 在接下来的文章中，我也会将其中一些重要部分单独梳理一遍。 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"小戴小戴","slug":"小戴小戴","date":"2022-09-25T06:19:54.000Z","updated":"2022-10-05T14:19:59.553Z","comments":true,"path":"/post/小戴小戴.html","link":"","permalink":"http://example.com/post/%E5%B0%8F%E6%88%B4%E5%B0%8F%E6%88%B4.html","excerpt":"","text":"小戴小戴，这里是小徐。","categories":[],"tags":[]},{"title":"Markdown语法学习，博客记录的开始~","slug":"markdown语法","date":"2022-09-24T15:08:35.025Z","updated":"2022-10-05T14:19:47.371Z","comments":true,"path":"/post/markdown语法.html","link":"","permalink":"http://example.com/post/markdown%E8%AF%AD%E6%B3%95.html","excerpt":"","text":"1.标题一共会有6个等级的标题，用#号表示，#数量越多，越小，一般情况下不要使用第一级标题，从二级标题开始用。 titlel1 我是一级titlel2 我是二级titlel3 我是三级titlel4 我是四级titlel5 我是五级titlel6 我是六级2.段落想要分段，在段尾输入至少两个以上的空格再回车；或者直接空一行再输入。 如：祝爷爷奶奶身体健康 祝我的家人生活幸福 这两句想要分段 就在第一句“祝爷爷奶奶身体健康”结束后空一整行再输入第二句“祝我的家人生活幸福”即可得到： 祝爷爷奶奶身体健康 祝我的家人生活幸福 3.字体3.1字体加粗：如想对“同济大学”加粗，在“同济大学”两侧分别加上两个“*”号，即可实现加粗。 “同济大学” 3.2字体倾斜：如想对“同济大学”倾斜，在“同济大学”两侧分别加上一个“*”号，即可实现倾斜。 “同济大学“ 3.3高亮：如想对“同济大学”高亮，在“同济大学”左边加上”&lt;mark&gt;”，右边加上”&lt;&#x2F;mark&gt;”,即可实现倾斜。 “同济大学“ 4.分隔线当文章段落过多，会影响整体可读性，此时可用分隔线对文章进行切分。 直接在单独的一行中输入三个“*”号。 或者使用多个“-”。 5.删除线在要添加删除线的文本两侧分别加上两个“~”。 文本文本文本 6.无序列表无序列表就是在输出多行文字，每行最前面带一个小点作为前缀。语法为一个“*”跟一个空格，后面输入文字，每行之间不需要空一行。 xxxxxxxxx yyyyyyyyy zzzzzzzzzz 7.有序列表有序列表就是用数字作为前缀。语法为一个数字带一个点跟一个空格，后面输入文字，每行之间不需要空一行。 xxxxxxxxxxxx yyyyyyyyyyyy zzzzzzzzzzzzz 8.列表嵌套在输入完第一个列表行后，想在这个列表行下在嵌套两个子列表行，则在第一个列表行的下一行开始连按四个空格，再逐个输入子列表行。 列表行A 子列表1 子列表2 列表行B 子列表1 子列表2 子列表3 9.区块区块是用来引用一段文本的。 语法为：一个”&gt;”跟一个空格，后面输入需要引用的文本。 如果要分段，则在第二行输入一个单独的”&gt;”，再换到第三行按照语法继续引用。 扬州是个好地方啊。 —-习近平 把扬州建设成为古代文化与现代文明交相辉映的名城。 —-江泽民 10.代码块代码块用来展示不同语言的代码。 语法为：上下分别使用三个点进行包裹，上下各占一行，在顶行的三个点右边写上代码语言的类型(java,go)从而让代码高亮，无需空格。 其中点为esc键下面的那个波浪键，注意一定要用英文的点。 123456public class Hello&#123; public static void main(String[] args)&#123; System.out.print(&quot;Hello,World!!&quot;); &#125;&#125; 1234567package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello,World!&quot;)&#125; 11.链接 直接插入 直接显示链接的网址，也即直接复制连接过来，点击网址即可跳转。 如 www.baidu.com 有时候无法识别网址，所以在插入链接的时候最好用“&lt;&gt;”包围来插入，这样百分百可识别为网址 文本链接 就是让一段文本具有链接跳转的功能。 语法为：英文下，一对方括号“[]”加上一对圆括号“（）”，在方括号内写文本，在圆括号内写链接网址，点击文本即可跳转,网址需要写全，前缀加上。 如：百度一下 12.图片直接将要插入的图片拖入图床，用markdown格式在vika模式下上传，然后直接粘贴就行了。 文字居中：不能直接按空格让文字居中，而是在文字左侧加”&lt;center&gt;”,右侧加”&lt;&#x2F;center&gt;”。 图片居中：在图片链接结尾的右括号前面加上”#pic_center”。 扮鬼脸的哆啦A梦！ 图1 13.表格 x y z a c e b d f 利用多个”|”，每两个“|”之间写内容。 在表格的第二行中，每两个“|”之间填的是“—”，减号数量不影响显示，这个不会显示出来，只是用来确定格式。 第二行和第一行保持一致，用“—”代替。在“—”的左右两边都可以添加冒号“:”,在左边添就是居左对齐，在右边添就是居右对齐，两边都添就是居中对齐。 x y z a c e b d f 14.转义字符如果我们想输出某些符号，但是在markdown里面有可能被识别成语法，此时需要在前面添上转义字符。 通常用反斜杠”&quot;直接加上符号，无需空格。 反斜杠英文下直接按enter键上面那个，不用按shift。 * 666 这是加了反斜杠的星号。 666 这是没加反斜杠的星号，被识别成无序列表前缀。 # ​","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/categories/Markdown/"}],"tags":[{"name":"Markdown语法基础","slug":"Markdown语法基础","permalink":"http://example.com/tags/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/categories/Markdown/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Markdown语法基础","slug":"Markdown语法基础","permalink":"http://example.com/tags/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}]}