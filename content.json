{"meta":{"title":"徐乔伟","subtitle":"","description":"徐乔伟的个人博客","author":"徐乔伟","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-09-25T08:04:37.346Z","updated":"2022-09-25T08:04:37.346Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2022-09-25T08:17:53.053Z","updated":"2022-09-25T08:17:53.053Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-25T08:06:39.390Z","updated":"2022-09-25T08:06:39.390Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"layout: friends # 必须title: 我的朋友们 # 可选，这是友链页的标题 这里写友链上方的内容。","text":"layout: friends # 必须title: 我的朋友们 # 可选，这是友链页的标题 这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2022-09-25T08:07:13.457Z","updated":"2022-09-25T08:07:13.457Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"从零实现Golang的HTTP标准库-（1）","slug":"从零实现Golang的HTTP标准库-（1）","date":"2022-10-05T02:21:31.000Z","updated":"2022-10-05T10:45:43.134Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-（1）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%EF%BC%881%EF%BC%89.html","excerpt":"","text":"1.前言在正式开始我们对Golang的HTTP标准库的实现之前，我还是想先推荐几个学习资源！ 这几个学习资源不是我们实现HTTP标准库所需的必备知识，所以我没有将他们放在前文的预备知识篇中，但是这几个资料的实现过程都和HTTP标准库有着一定相同的地方。 但如果你能够提前对以下推荐的几个学习资源事先做了阅读与研究，那么在实现Golang的HTTP标准库的过程中一定会如鱼得水，得心应手。 B站韩顺平的网络编程部分p294-p343 这一部分韩老师讲解了一个案例，其中的服务端部分思路值得借鉴。 B站刘丹冰的Zinx轻量级TCP服务框架 这个课程的质量非常高，up主刘丹冰老师的讲课风格十分干练，直击重点。在这门课中，老师实现了一个TCP服务框架，其实非常类似于我们将要实现的HTTP标准库，有很多思路都是共通的。我强烈建议大家有空的时候先完成对这门课程的学习，一定能够在这门课程中提前学到HTTP标准库的一些难点。 一位华科同学的博客 这个博客的博主是华中科技大学的一名计算机专业研究生，他在博客中记录了自己实现HTTP标准库的过程，其质量之高，让我收获良多。但由于博主计算机基础非常扎实，其语言风格比较干练，默认读者具有了一定的网络编程水平，故我在阅读的过程中对于一些细节之处难以理解，遇到了不少的阻碍。经过反复阅读与研究，我在阅读过程中做了不少的笔记，都是基于原博客写出来的，可以说，正是看了原博主的关于从零实现HTTP标准库的内容，让我萌发了对HTTP标准库研究的兴趣。所以，无论你之前是否有过网络编程基础，只要你想尝试研究实现HTTP标准库，你都应该或者说必须去看看这个博客。对于基础好的同学，我相信原博客内容已经能够满足你的需要；对于一些和我一样事先不太了解网络底层编程的同学，我觉得你仍需先看看原文的博客，当看到某处难以理解时，可以参考参考我博客中对应的地方，也许这处也是我当时疑惑的点。因此强烈建议各位去看看这个博客，我在此也对博主辜飞俊同学表示感谢！ 极客时间web框架教程 这是一门手把手教你写一个web框架的课程，总体来说应该具有一定的难度。我目前也没有学习完这门课程，但我认为其质量也是非常好的，可以作为我们实现完HTTP框架后的一个进阶与补充。其中，文章开头就以Golang的net&#x2F;HTTP标准库为例，引领读者一步步实现web框架。 以上四个内容都是我在学习过程中发现的优质资源，都对我有着比较大的帮助，所以也分享出来给大家学习。 2.概述Go语言的官方net&#x2F;HTTP标准库，搭建一个webServer非常容易。因为这个搭建过程中所使用到的函数、方法、接口往往是标准库帮我们封装好了的，我们只需要根据现成的已有的工具即可完成搭建。而我们今天将要实现的自然并不是使用现成的工具，而是要钻进HTTP标准库源码中，看看这些工具是怎么设计、怎么封装的。 3.webServerwebServer在维基百科上的解释为：Web Server 是一个通过 HTTP 协议处理 Web 请求的计算机系统。 HTTP 协议，在 OSI 网络体系结构中，是基于 TCP&#x2F;IP 之上第七层应用层的协议，全称叫做超文本传输协议。啥意思？就是说 HTTP 协议传输的都是文本字符，只是这些字符是有规则排列的。这些字符的排列规则，就是一种约定，也就是协议。这个协议还有一个专门的描述文档，就是RFC 2616。 对于 HTTP 协议，无论是请求还是响应，传输的消息体都可以分为两个部分：HTTP 头部和 HTTP Body 体。头部描述的一般是和业务无关但与传输相关的信息，比如请求地址、编码格式、缓存时长等；Body 里面主要描述的是与业务相关的信息。 Web Server 的本质，实际上就是接收、解析 HTTP 请求传输的文本字符，理解这些文本字符的指令，然后进行计算，再将返回值组织成 HTTP 响应的文本字符，通过 TCP 网络传输回去。 4.标准库启动Web服务的示例用 net&#x2F;http 来创建一个 HTTP 服务，其实很简单，下面是官方文档里的例子。我做了些注释，帮你理解。 1234567891011// 创建一个Foo路由和处理函数http.Handle(&quot;/foo&quot;, fooHandler)// 创建一个bar路由和处理函数http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))&#125;)// 监听8080端口log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil)) 有基础的同学是可以看得懂上述代码的，无非是注册了两个路由，然后让服务器监听在8080端口上并运行。 但是零基础的同学看着上述代码，那可就疑问多多了，Handle是啥？HandleFunc是啥？ListenAndServe又是啥？有什么作用呢？不要担心，我最开始也是这样。 不要在意上面的代码细节，暂时有个印象，先继续往下看吧！ 5.自编代码启动Web服务第4节中的代码是官方的写法，他其实已经是经过了一些封装和简化的，那我们现在就自己动手写一个启动Web服务的代码，没有封装、没有简化，从这个自编代码入手开始学习！ 注意：官方代码中前两个方法是注册路由，关于这一块我们目前无需涉及，所以我先将路由这部分省略！ 1234567891011121314151617package mainimport &quot;net/http&quot;type myHandler struct&#123;&#125;func (*myHandler) ServeHTTP(w http.ResponseWriter,r *http.Request)&#123; w.Write([]byte(&quot;hello world!&quot;))&#125;func main()&#123; svr:=&amp;http.Server&#123; Addr: &quot;127.0.0.1:8080&quot;, Handler: new(myHandler), &#125; panic(svr.ListenAndServe())&#125; 我们来解析一下上述代码！解析过程并没有按照代码顺序，因为代码间存在先后因果的逻辑关系，需要仔细梳理！ 第1-3行为在main包下，引入“net&#x2F;http”库。 在main函数中，第12行我们初始化了一个http.server的对象并对其进行属性进行赋值，起名叫svr。 那么这个http.server是什么呢？它其实是一个结构体，代表了一个我们将要启动的服务器。 123456789type Server struct &#123; // 请求监听地址 Addr string // 请求核心处理函数 Handler Handler // 为了理解方便，其余非核心属性省略 ...&#125; 你可以看到这个server服务器结构体中有两个核心属性： 一个是String类型的Addr，初始化server时给Addr赋值表示希望服务器监听哪个地址端口； 一个是Handler类型的Handler，Handler是一个有ServeHTTP方法的接口，就好比一个拦截所有http请求的拦截器，告诉框架如何处理来自客户端的所有http请求。 我们来重点解析一下这个Handler接口。它代表了一个抽象的业务处理逻辑。 在自编代码中，我们在初始化服务器对象时，除了给Addr赋值，我们也给Handler属性进行了赋值，其值为myHandler。 显而易见，这个myHandler是我们自己定义的一个结构体，它会去实现Handler接口，因而myHandler可以赋值给Handler。前面说了这个Handler代表了一个抽象的业务处理逻辑，我们自己写这个myHandler并赋值给Handler，目的就是我们想要自己定义这个处理逻辑。 注意： 不论是Handler还是myHandler，他们都是代表抽象的笼统的，请不要将myHandler理解为具体的业务处理方法。具体的处理方法是另一个东西叫serverHTTP方法，这个serverHTTP方法是Handler接口里的一个成员方法，而myHandler结构体实现了Handler里的这个成员方法，也即实现了Handler接口。 在初始化server时，也可以不给Handler进行赋值，也即我们不想要自定义处理方法，那么这时候标准库会启动自己的默认处理方式。 在serverHTTP方法中我们才真正的去定义具体的业务请求处理方法。 比如在自编代码中，我们对业务请求的处理非常简单：直接输出“hello world!” 关于这个serverHTTP方法的参数： w http.ResponseWriter ：从名字你可以将它理解为“响应构造器”。当我们收到一个HTTP请求后，我们的框架会对这个请求进行处理。请求处理完毕后，肯定要往回发送一个响应。我们直接调用这个响应构造器w的write方法，即可完成响应的发送。 r *http.Request ：这个很简单，就是我们服务器或者框架从客户端收到的请求。这个请求的类型为Request，很显然，这个类型到时候是需要我们后面自己构建的。 其实，当客户端发来一个请求时，它的请求形式是一个HTTP请求报文的形式。而我们服务器对客户端的响应也是一个HTTP响应报文的形式。我们框架要做的就是当接收到HTTP报文后，我们对HTTP报文进行解析，获取关键信息并将其封装成一个Request结构体形式，代表一个请求。有了这个请求后，进行处理请求，通过响应构造器的write方法构建一个HTTP响应报文，再将其发送回去。 最后，关于ListenAndServe()函数，可以参照一下下面这幅图。 这部分其实就和go的socket编程相关。 如果你觉得层次比较多，对照着思维导图多看几遍就顺畅了。这里我也给你整理了一下逻辑线各层的关键结论： 第一层，标准库创建 HTTP 服务是通过创建一个 Server 数据结构完成的； 第二层，Server 数据结构在 for 循环中不断监听每一个连接； 第三层，每个连接默认开启一个 Goroutine 为其服务； 第四、五层，serverHandler 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理； 第六层，Server 数据结构如果没有设置处理函数 Handler，默认使用 DefaultServerMux 处理请求； 第七层，DefaultServerMux 是使用 map 结构来存储和查找路由规则。 最后，再多说一句，这个Handler接口除了有自定义处理逻辑的功能外，还有着路由的功能。 Handler的存在给框架的拓展带来了极大的灵活性，有了Handler，我们可以让任何一个HTTP请求以自己的规则映射到自己的路由。比如http标准库用ServeMux类型实现了Handler接口，从而实现了静态路由(将在本系列的末尾讨论)；gin的gin.Engine也是实现了自己的Handler，有了动态路由功能。 路由部分我们最后再说。 6.自定义框架的需求分析从需求分析的角度出发，看看我们要实现的web框架大体上需要哪些功能： http协议的解析不应该由开发者完成，我们需要从tcp字节流中解析出http的报文。 框架需要设置Request并为Request绑定易用API。 框架需要设置Response并为Response绑定易用API。 乍一看，我们需要给框架完成的功能甚少，但每一步都会有很多情况需要处理： 比如对于http 1.1协议来说，因为支持长连接，一个tcp连接能发送多个http请求，如果框架未正确完成上一个请求的解析(如未将当前报文主体全部读完)，那么随之到来的下一个请求就无法正确解析。 客户端有时会以chunk方式传输报文主体，我们应该保证用户read到的只有有效载荷(playload)，而没有chunk协议里的控制信息。 前端提交上来的form表单有多种类型，最常见的如application&#x2F;x-www-form-urlencoded以及multipart&#x2F;form-data，我们框架应该予以区分并分别提供解析方法。 服务端发送的数据是放在http响应报文的响应体中，客户端怎么知道我们发送了多少数据呢？一般来说可以查看响应头中的Content-Length字段，从而知道响应体的长度。观察上述的代码的ServeHTTP方法，我们并没有显式为头部指定Content-Length，但客户端依旧可以完整的读取出数据，这就说明标准库帮助我们完成了相关的设置工作。 从可行性角度来说，框架为我们的每一次响应都自动正确设置Content-Length(以下简称CT)是不现实的，发送CT所在的响应头必须是先于发送响应报文主体的，如果框架要自动设置CT，也就意味着我们必须为用户Write的所有数据进行缓存，这对一定长度内的发送量还实用，但对于大响应主体来说绝对是不可行。所以我们的框架还需要在必要时刻转化为利用chunk方式传输数据，这一部分对用户来说必须是无感知的。 7.总结本篇是从零实现Golang的HTTP标准库服务端部分的第一篇，开头给大家推荐了几个优秀的学习资源，然后介绍了webServer，标准库启动webServer的方法以及我们自定义启动webServer的方法并进行了详细的分析，最后给出了我们框架的需求以及难点。 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"从零实现Golang的HTTP标准库-预备知识（2）","slug":"从零实现Golang的HTTP标准库-预备知识（2）","date":"2022-10-04T14:17:12.000Z","updated":"2022-10-04T10:30:26.038Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-预备知识（2）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89.html","excerpt":"","text":"1.概述在预备知识（1）中，我们介绍了三个学习内容，其中前两个学习内容：go语言的基础语法以及计算机网络的概念了解，我们不再详细介绍与梳理，请读者自行完成这两个部分的学习。 在本篇中，我将对socket编程流程做一个简单的介绍，同时梳理一下go语言的socket编程。 本篇默认你已经对socket有所了解，故基本的概念性问题将不再被提及。如果你在阅读以下内容的过程中，有任何不明白的地方，去看上一篇文章中推荐的学习资源，里面应该都会有答案，或者直接网上搜索疑问。 2.传统TCP套接字编程流程注意：以下内容是我学习《计算机网络自顶向下》中相关部分自己总结而来，可能存在说辞严谨性问题，目的只是为了提供给大家一个借鉴和参考。具体也可以听一听中科大郑老师的课上的讲解！ TCP套接字编程流程：1 服务器首先运行，等待连接建立。 1.1 服务器创建一个欢迎socket，即可以返回一个整数。 此时这个整数无任何意义。创建socket可以调用socket API的创建函数。 1.2 将这个整数和服务器本地的IP和服务器本地端口相捆绑，捆绑可以调用socket API的捆绑函数。 1.3 在服务器的欢迎scoket上阻塞式的等待接收用户的连接。即调用socket API的accept函数，接收来自远端的用户和服务器的欢迎scoket进行TCP连接。如果此时没有连接，则函数停在当前不往下走，即阻塞式等待连接。 2 客户端主动与服务器建立连接 2.1 客户端创建本地socket，不需要捆绑，是隐式自动捆绑。 2.2 指定服务器进程的IP地址和端口号，与服务器进程连接。 3 服务器收到来自客户端的连接请求3.1 服务器接收来自用户端的连接请求，解除阻塞式等待。 此时服务器会返回一个新的socket整数 新的socket叫connection socket，这个connection socket仍然和服务器的IP、端口捆绑但同时connection socket又和客户端的IP和端口相捆绑。此时连接建立完成。 这个新的connection socket就是通道，在这个通道上就可以收和发。 3.传统TCP套接字编程伪代码1.welcomeSocket&#x3D;Socket（）;&#x2F;&#x2F;创建一个欢迎socket 2.bind（welcomeSocket&amp;sad）&#x2F;&#x2F;将欢迎socket和服务器本地IP、端口相捆绑 3.connectionSocket&#x3D;accept（welcomeSocket）&#x2F;&#x2F;在welcomeSocket所在的的端口上阻塞式等待来自客户端用户的连接请求 4.clientSocket&#x3D;socket（）；&#x2F;&#x2F;创建一个客户端本地的clientSocket 5.connect（clientSocket，sad）&#x2F;&#x2F;将客户端的socket和服务器的ip、端口捆绑此时客户端的TCP实体向服务端发出一个连接建立请求，服务端收到请求后解除阻塞，accept会返回一个新的值connectionSocket，且服务端TCP实体给出连接建立响应，客户端处connect返回一个有效值clientSocket，此时连接建立。 6.客户端用clientSocket发送信息，用到send函数。 7.服务器端用connectionSocket接收信息，用到read函数。 8.服务器端用connectionSocket处理信息，用到write函数。 9.客户端用clientSocket接收信息，用到read函数。 10.关闭掉本次connectionSocket，等待用户下一次连接建立请求。关闭掉本次clientSocket。 用到close函数 以上为传统编码形式的TCP Socket编程。 (1) 建立Socket：使用socket()函数。 (2) 绑定Socket：使用bind()函数。 (3) 监听：使用listen()函数。或者连接：使用connect()函数。 (4) 接受连接：使用accept()函数。 (5) 接收：使用receive()函数。或者发送：使用send()函数。 4.go的socket编程以下内容是我学习B站韩顺平老师go语言基础课中网络编程部分的笔记，具体代码可以去视频中参考。 Golang TCP Socket编程： 1.分为服务器端和客户端，客户端可以有多个。 2.服务器端在8888端口监听，等待客户端的连接。 3.客户端向服务器端IP地址的端口8888建立连接，这个连接的双向箭头是Conn类型的，先记住。 4.服务器端有一个主线程P，当某一个客户端与服务器端建立连接后，这个主线程会开辟一个单独的协程goroutine来处理这个客户端的请求。 5.若有多个客户端，则可以开辟多个协程来处理。 5.go语言net包中的主要函数介绍本部分主要介绍net包中一些以后会用到的函数方法，详细内容参考以下链接。 https://studygolang.com/pkgdoc 12package netimport &quot;net&quot; net包提供了可移植的网络I&#x2F;O接口，包括TCP&#x2F;IP、UDP、域名解析和Unix域socket。 虽然本包提供了对网络原语的访问，大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。 1.Listen函数 func Listen(net, laddr string) (Listener, error)，用Listener类型和error类型接收。 解析：Listen函数是net包直接调用的函数，写作net.Listen（）。它里面含有两个参数，其中net是指网络协议的类型：TCP,UDP等，laddr是一个网络地址，由IP：端口号组成。Listen函数的作用是返回在一个本地网络地址laddr上监听的Listener。 net.Listen（x1，x2）就代表让服务器守候在x2端口上等候客户端的连接请求，并且连接必须是x1协议类型的。 2.Listener接口 12345678type Listener interface &#123; // Addr返回该接口的网络终端地址 Addr() Addr // Accept等待并返回下一个连接到该接口的连接 Accept() (c Conn, err error) // Close关闭该接口，并使任何阻塞的Accept操作都会不再阻塞并返回错误。 Close() error &#125; 如上所示，Listenr是一个监听接口类型，它是Listen函数的返回值类型。 比如说listenr是Listen函数的返回值，listener是Listener接口类型的“对象”。由最初的TCP套接字编程流程可知，accept函数是阻塞式的等待客户端和服务器进行连接，若连接上了，返回一个connection socket。 若没有连接上，则继续等待。在这里我们就可以用listenr对象调用Accept方法来实现。即listener.Accept（），因为accept是接口里的方法，所以可以直接调用。又因为需要阻塞式等待，所以该语句应该写在一个无限循环中。listener代表一个监听接口对象。关闭listener代表不监听了。 Accept() (c Conn, err error)再来细看Accept方法，返回值是Conn类型和error类型。 2.Conn接口 1234567891011121314type Conn interface &#123; // Read从连接中读取数据 Read(b []byte) (n int, err error) // Write从连接中写入数据 Write(b []byte) (n int, err error) // Close方法关闭该连接 // 并会导致任何阻塞中的Read或Write方法不再阻塞并返回错误 Close() error // 返回本地网络地址 LocalAddr() Addr // 返回远端网络地址 RemoteAddr() Addr&#125; Conn是Accept函数的返回值类型。 Conn接口代表网络连接。多个线程可能会同时调用同一个Conn的方法。 Conn也是一个接口类型。 这个Conn类型代表了一个客户端与服务器端的连接，也即前面图中提到的双向箭头，就是Conn接口类型的。 假如设Conn接口的对象是conn，那么这个conn就是传统编码中服务器端返回的那个connection socket。我们可以对这个conn进行读数据操作和写数据操作。 6.总结以上内容是我当时在学习这些知识时自己做的一些笔记，仅供大家参考！ 当你差不多掌握了上述预备知识以后，下面我们将真正步入Golang的HTTP标准库的实现中去！ 对于上述内容，你可以在实践的过程中慢慢体会！ 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"从零实现Golang的HTTP标准库-预备知识（1）","slug":"从零实现Golang的HTTP标准库-预备知识（1）","date":"2022-09-25T14:09:40.000Z","updated":"2022-10-04T10:32:00.663Z","comments":true,"path":"/post/从零实现Golang的HTTP标准库-预备知识（1）.html","link":"","permalink":"http://example.com/post/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Golang%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89.html","excerpt":"","text":"1.概述在我们从零实现Golang的HTTP标准库之前，我们首先需要学习一些预备知识，学习了这些预备知识作为基础以后，我们才能更好的理解Golang的HTTTP标准库的代码，也有利于我们后面自己动手实现它。 在预备知识中，我不会过多介绍关于Golang的HTTP标准库有关的内容，这一部分的介绍等我们学习完预备知识以后，会更新在后续的真正实现HTTP标准库的文章中。 2.所需要的预备知识以及学习资源推荐 Golang的基本语法 B站韩顺平的go语言基础课 《go语言编程基础》 国内七牛云团队编写的书，国人编写，通俗易懂 《go语言程序设计》 Go语言圣经，经典书籍但翻译略显晦涩 因为我们是要实现Golang的HTTP标准库，所以首先我们需要了解Golang这门语言的基础语法。 当然，我们不需要对Go语言有特别深入的了解，只需要掌握一些基础的部分，如：变量的定义、结构体的创建、给结构体绑定函数、接口的定义、接口的实现、for循环的写法、结构体对象的初始化等等，以上这些经常出现在标准库代码中。 至于Go语言的一些深入特性，如闭包、管道、Groutine协程等的底层原理，在本系列中无需知晓，只需知道其作用即可。 计算机网络 B站中科大计算机网络教程 《计算机网络自顶向下》 经典书籍，你只需学习书中的应用层和传输层即可，在传输层的结尾你会了解到传统socket的编程方式。 这门课是计算机科学与技术专业或软件工程专业学生的必修专业课，要想知道什么是HTTP，自然离不开计算机网络的学习。 你需要学习有关于传输层的知识，包括TCP等，以及什么是socket。力求对于计算机网络课程有一个大体的概念了解。 go语言的socket编程 B站韩顺平的go语言基础课网络编程部分 在计算机网络课程中，你会了解到什么是socket，以及传统的socket编程方式流程步骤。 但是在go语言中，有着自己的一套socket编程方法，但是大体的思路原理却是一致的，所以你仍需先学习计算机网络，了解传统的socket编程，在此基础上，学习go语言的socket编程将会事半功倍。 注意：我们需要学习的是有关于TCP的socket编程。 3.总结关于上述的三个知识点或者说三部分学习内容，难度不大，不需要花费你太多的精力。 但是却是我们实现Golang的HTTP标准库的基础，所以需要认真学习对待。 在接下来的文章中，我也会将其中一些重要部分单独梳理一遍。 本篇到此结束，感谢你的阅读！","categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"小戴小戴","slug":"小戴小戴","date":"2022-09-25T06:19:54.000Z","updated":"2022-09-25T14:59:51.960Z","comments":true,"path":"/post/小戴小戴.html","link":"","permalink":"http://example.com/post/%E5%B0%8F%E6%88%B4%E5%B0%8F%E6%88%B4.html","excerpt":"","text":"小戴小戴，这里是小徐。","categories":[{"name":"分类2","slug":"分类2","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE2/"},{"name":"标签3","slug":"标签3","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE3/"}]},{"title":"Markdown语法学习，博客记录的开始~","slug":"markdown语法","date":"2022-09-24T15:08:35.025Z","updated":"2022-10-05T02:24:17.543Z","comments":true,"path":"/post/markdown语法.html","link":"","permalink":"http://example.com/post/markdown%E8%AF%AD%E6%B3%95.html","excerpt":"","text":"1.标题一共会有6个等级的标题，用#号表示，#数量越多，越小，一般情况下不要使用第一级标题，从二级标题开始用。 titlel1 我是一级titlel2 我是二级titlel3 我是三级titlel4 我是四级titlel5 我是五级titlel6 我是六级2.段落想要分段，在段尾输入至少两个以上的空格再回车；或者直接空一行再输入。 如：祝爷爷奶奶身体健康 祝我的家人生活幸福 这两句想要分段 就在第一句“祝爷爷奶奶身体健康”结束后空一整行再输入第二句“祝我的家人生活幸福”即可得到： 祝爷爷奶奶身体健康 祝我的家人生活幸福 3.字体3.1字体加粗：如想对“同济大学”加粗，在“同济大学”两侧分别加上两个“*”号，即可实现加粗。 “同济大学” 3.2字体倾斜：如想对“同济大学”倾斜，在“同济大学”两侧分别加上一个“*”号，即可实现倾斜。 “同济大学“ 3.3高亮：如想对“同济大学”高亮，在“同济大学”左边加上”&lt;mark&gt;”，右边加上”&lt;&#x2F;mark&gt;”,即可实现倾斜。 “同济大学“ 4.分隔线当文章段落过多，会影响整体可读性，此时可用分隔线对文章进行切分。 直接在单独的一行中输入三个“*”号。 或者使用多个“-”。 5.删除线在要添加删除线的文本两侧分别加上两个“~”。 文本文本文本 6.无序列表无序列表就是在输出多行文字，每行最前面带一个小点作为前缀。语法为一个“*”跟一个空格，后面输入文字，每行之间不需要空一行。 xxxxxxxxx yyyyyyyyy zzzzzzzzzz 7.有序列表有序列表就是用数字作为前缀。语法为一个数字带一个点跟一个空格，后面输入文字，每行之间不需要空一行。 xxxxxxxxxxxx yyyyyyyyyyyy zzzzzzzzzzzzz 8.列表嵌套在输入完第一个列表行后，想在这个列表行下在嵌套两个子列表行，则在第一个列表行的下一行开始连按四个空格，再逐个输入子列表行。 列表行A 子列表1 子列表2 列表行B 子列表1 子列表2 子列表3 9.区块区块是用来引用一段文本的。 语法为：一个”&gt;”跟一个空格，后面输入需要引用的文本。 如果要分段，则在第二行输入一个单独的”&gt;”，再换到第三行按照语法继续引用。 扬州是个好地方啊。 —-习近平 把扬州建设成为古代文化与现代文明交相辉映的名城。 —-江泽民 10.代码块代码块用来展示不同语言的代码。 语法为：上下分别使用三个点进行包裹，上下各占一行，在顶行的三个点右边写上代码语言的类型(java,go)从而让代码高亮，无需空格。 其中点为esc键下面的那个波浪键，注意一定要用英文的点。 123456public class Hello&#123; public static void main(String[] args)&#123; System.out.print(&quot;Hello,World!!&quot;); &#125;&#125; 1234567package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello,World!&quot;)&#125; 11.链接 直接插入 直接显示链接的网址，也即直接复制连接过来，点击网址即可跳转。 如 www.baidu.com 有时候无法识别网址，所以在插入链接的时候最好用“&lt;&gt;”包围来插入，这样百分百可识别为网址 文本链接 就是让一段文本具有链接跳转的功能。 语法为：英文下，一对方括号“[]”加上一对圆括号“（）”，在方括号内写文本，在圆括号内写链接网址，点击文本即可跳转,网址需要写全，前缀加上。 如：百度一下 12.图片直接将要插入的图片拖入图床，用markdown格式在vika模式下上传，然后直接粘贴就行了。 文字居中：不能直接按空格让文字居中，而是在文字左侧加”&lt;center&gt;”,右侧加”&lt;&#x2F;center&gt;”。 图片居中：在图片链接结尾的右括号前面加上”#pic_center”。 扮鬼脸的哆啦A梦！ 图1 13.表格 x y z a c e b d f 利用多个”|”，每两个“|”之间写内容。 在表格的第二行中，每两个“|”之间填的是“—”，减号数量不影响显示，这个不会显示出来，只是用来确定格式。 第二行和第一行保持一致，用“—”代替。在“—”的左右两边都可以添加冒号“:”,在左边添就是居左对齐，在右边添就是居右对齐，两边都添就是居中对齐。 x y z a c e b d f 14.转义字符如果我们想输出某些符号，但是在markdown里面有可能被识别成语法，此时需要在前面添上转义字符。 通常用反斜杠”&quot;直接加上符号，无需空格。 反斜杠英文下直接按enter键上面那个，不用按shift。 * 666 这是加了反斜杠的星号。 666 这是没加反斜杠的星号，被识别成无序列表前缀。 # ​","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Markdown语法基础","slug":"Markdown语法基础","permalink":"http://example.com/tags/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"从零实现HTTP标准库","slug":"从零实现HTTP标准库","permalink":"http://example.com/categories/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0HTTP%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"分类2","slug":"分类2","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB2/"},{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"标签1","slug":"标签1","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE2/"},{"name":"标签3","slug":"标签3","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE3/"},{"name":"Markdown语法基础","slug":"Markdown语法基础","permalink":"http://example.com/tags/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"}]}